# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод init()), который должен принимать данные
# (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц: см. в методичке.
#
# Следующий шаг — реализовать перегрузку метода str() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода add() для реализации операции сложения двух объектов класса Matrix (двух матриц). Результатом сложения
# должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с первым элементом первой
# строки второй матрицы и т.д.
#
# class Matrix:
#     def __init__(self, list_1, list_2):
#         # self.matr = [list_1, list_2]
#         self.list_1 = list_1
#         self.list_2 = list_2
#
#     def __add__(self):
#         matr = [[0, 0, 0],
#                 [0, 0, 0],
#                 [0, 0, 0]]
#
#         for i in range(len(self.list_1)):
#
#             for j in range(len(self.list_2[i])):
#                 matr[i][j] = self.list_1[i][j] + self.list_2[i][j]
#
#         return str('\n'.join(['\t'.join([str(j) for j in i]) for i in matr]))
#
#
#     def __str__(self):
#         return str('\n'.join(['\t'.join([str(j) for j in i]) for i in matr]))
#
#
# my_matrix = Matrix([[6, 8, 11], [6, 17, 44], [41, 5, 9]],
#                    [[48, 8, 2], [6, 2, 93], [24, 5, 37]])
#
# print(my_matrix.__add__())

# 2. Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная сущность (класс) этого проекта — одежда, которая может
# иметь определенное название. К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры: размер (для пальто)
# и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3). Проверить работу этих
# методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов
# проекта, проверить на практике работу декоратора @property.
#
# class Clothes:
#     def __init__(self, width, height):
#         self.width = width
#         self.height = height
#
#     def m_coat (self):
#         return self.width / 6.5 + 0.5
#
#     def m_costume (self):
#         return self.height * 2 + 0.3
#
#     @property
#     def m_sq_full(self):
#         return str(f'Площадь общая ткани \n'
#                    f' {(self.width / 6.5 + 0.5) + (self.height * 2 + 0.3)}')
#
#
# class Coat(Clothes):
#     def __init__(self, width, height):
#         super().__init__(width, height)
#         self.m_coat = round(self.width / 6.5 + 0.5)
#
#     def __str__(self):
#         return f'Расход ткани на пальто {self.m_coat}'
#
#
# class Costume(Clothes):
#     def __init__(self, width, height):
#         super().__init__(width, height)
#         self.m_costume = round(self.height * 2 + 0.3)
#
#     def __str__(self):
#         return f'Расход ткани на костюм {self.m_costume}'
#
# coat = Coat(44, 170)
# costume = Costume(46, 168)
# print(coat)
# print(costume)
# print(coat.m_sq_full)
# print(costume.m_sq_full)
# print(costume.m_coat())



# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка. В его конструкторе инициализировать
# параметр, соответствующий количеству ячеек клетки (целое число). В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (add()), вычитание (sub()), умножение (mul()), деление (truediv()). Данные методы должны применяться только к клеткам и выполнять увеличение,
# уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля, иначе выводить
# соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный метод позволяет организовать
# ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если ячеек на формирование
# ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.
#
class Cell:
    def __init__(self, quantity):
        self.quantity = int(quantity)

    def __str__(self):
        return f'Результат операции {self.quantity * "*"}'

    def __add__(self, other):
        return Cell(self.quantity + other.quantity)

    def __sub__(self, other):
        return self.quantity - other.quantity if (self.quantity - other.quantity) > 0 else print('Отрицательно!')

    def __mul__(self, other):
        return Cell(int(self.quantity * other.quantity))

    def __truediv__(self, other):
        return Cell(round(self.quantity // other.quantity))

    def make_order(self, cells_in_row):
        row = ''
        for i in range(int(self.quantity / cells_in_row)):
            row += f'{"*" * cells_in_row} \\n'
        row += f'{"*" * (self.quantity % cells_in_row)}'
        return row

cells1 = Cell(4)
cells2 = Cell(10)
print(cells1)
print(cells1 + cells2)
print(cells2 - cells1)
print(cells2.make_order(5))
print(cells1.make_order(12))
print(cells1 / cells2)
